---
title: 10 Algorithms Every Developer Should Learn
description: 'There seems to be a large misconception from a lot of aspiring devs that _memorizing_ standard algorithms is important. Now for some job interviews that may be the case, but it is not particularly important for actually being a successful developer.'
category: Algorithms
date: Dec 22 2022
img: https://dummyimage.com/200x200/ffffff/1421d9.png&text=200x200
---

# 10 Algorithms Every Developer Should Learn

![](https://miro.medium.com/max/875/1*CM5ik7U5aCIjRmRaoElZBg.png)

There seems to be a large misconception from a lot of aspiring devs that _memorizing_ standard algorithms is important. Now for some job interviews that may be the case, but it is not particularly important for actually being a successful developer.

So are the things you learn in an algorithm class useless? Absolutely not. What is incredibly important is the ability to think algorithmically. Not just so that you can reproduce and altar standard algorithms, but so that you are comfortable using code to solve whatever problems you encounter as a dev.

That’s why we’ve assembled a list of 10 algorithms that aspiring devs should work-through to get comfortable with thinking algorithmically.

## 1\. Binary Search

Binary search is one of the first things taught in any computer science class. It is perhaps the simplest example of how a little bit of ingenuity can make things, quite literally, exponentially more efficient.

A binary search consists of taking a sorted array, and iteratively splitting the array into two and comparing an element that you are looking for against each half, until you find the element.

## 2\. Selection, Bubble, and Insertion Sort

Sorting algorithms are one of the most fundamental tools that a developer should have in their arsenal. Selection, Bubble, and Insertion sort are some of the first that new developers should work through. In any scenario when speed matters you’re not going to be using these algorithms but working with them is a great introduction to array traversal and manipulation.

## 3\. Quicksort and Mergesort

Similar to #2, sorting algorithms are great for getting comfortable with arrays, but Quicksort and Mergesort are efficient enough to be used in serious applications. Being comfortable implementing these sorting algorithms(Note ‘Being comfortable’ and not ‘memorizing’) these algorithms are essential to being a serious developer.

## 4\. Huffman Coding

Huffman coding is the foundation of modern text compression. It works by considering how often different characters appear in a text, and organizes them in a tree based on this frequency.

![](https://miro.medium.com/proxy/0*fy0YagBrbYphpIfU)

Taking the time to work with Huffman coding is a great way to get comfortable with data representation and tree traversal, which are two of the most important issues that computer scientists need to be able to grapple with.

## **5\. Breadth First Search**

Again, trees turn out to be at the heart of a lot of algorithms and software that developers work with. As such, understanding basic tree traversal is a top priority for an aspiring developer.

Breadth first search works by exploring a tree level by level until the target node is found. Since it literally going through every level it is guaranteed to find a solution

![](https://miro.medium.com/proxy/0*J5PQwABSYOXvsmYy)

## **6\. Depth First Search**

Continuing with tree traversal, Depth-First Search is the other main approach for finding an element in a tree. Instead of working down the tree level by level, it explores the tree branch by branch.

![](https://miro.medium.com/proxy/0*8O1qtlSca-L2zQS4)

Now assuming it does not have infinitely extended branches, DFS will similarly always work. Implementing these two search algorithms aren’t particularly complex, but what is incredibly important is learning when to use one over the other. A lot of software design is being able to understand the structure of the information you are working with, and pick algorithms that optimize for that structure.

## **7\. Gradient Descent**

Now for a lot of developers, Gradient Descent is not necessarily going to be useful. If, however, you are touching anything with regression or machine learning, Gradient Descent is going to be at the heart of your work.

![](https://miro.medium.com/proxy/0*lHsYg8hLyTuRbUPj)

Gradient Descent is a method of procedure optimizing functions using calculus. In the context of regression and machine learning, this means finding specific values that minimize the error in your prediction algorithm. While it is certainly more mathematically involved that a lot of these other algorithms, if you are working significantly with data and predictions, understanding how gradient descent works is incredibly important.

## **8\. Dijkstra’s Algorithm**

Another incredibly important issue that developers work with is path finding. Graphs turn out to be an incredibly versatile way to describe all kinds of problems that involve networks of distinct objects.

![](https://miro.medium.com/proxy/0*Y9iYkNkbVy9T5Yp6)

Dijkstra’s algorithm is a way of finding the quickest path between two nodes in a graph. It is the foundation of most work done in path-finding and finds itself used in anything from artificial intelligence to game design.

## **9\. Diffie-Helllman Key Exchange**

The Diffie-Hellman Key Exchange is a great introduction to how cryptography tends to work. More specifically, a Diffie-Hellman Key Exchange works by combining public and private keys(Which are effectively long numbers) to encrypt information when it is being transferred between different parties.

![](https://miro.medium.com/proxy/0*9og-WCqQOSCejvkx)

Even if you’re not working in cybersecurity, having a working understanding of encryption and secure communication is incredibly important to working as a developer. Additionally, even though Diffie-Helman is far from the best algorithm, it is incredibly easy to implement and is similar enough to most other encrypted communication methods.

## 10\. Doing Practice Problems

These first nine algorithms all gave you ways to solve archetypes of problems you might encounter as a developer. The reality, however, is that as a developer you are often going to be encountering algorithmic problems that are completely new. That’s why more important than memorizing any algorithm, is developing the ability to solve problems algorithmically.

Luckily, there is no shortage of websites to practice. Some of our favorites are:

- [https://leetcode.com/](https://leetcode.com/)
- [https://projecteuler.net/](https://projecteuler.net/)(More mathematical)
- [https://www.hackerrank.com/](https://www.hackerrank.com/)

These are great environments to find difficult, yet fulfilling algorithmic problems and hone your skills.

## So Now What?

Again, do not just memorize these algorithms and think you are suddenly a better developer for it. Software Engineering, first and foremost, is about being able to understand problems and build solutions. Learning algorithms isn’t important because you are going to have to exactly implement them for something you’re building. They are important because they teach you how to approach problems.

What did we leave off the list? Let us know down below.

As always, happy coding from your friends at [Codesphere](https://link.codesphere.com/MY), the swiss-army knife every development team needs.

## Credit

![Codesphere](https://miro.medium.com/fit/c/60/60/1*an7W8VpGD0t9aWY-qsa8Ew.png)
